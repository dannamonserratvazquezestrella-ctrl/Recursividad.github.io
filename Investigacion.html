<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recursividad</title>
  <style>
    /* ----------- ESTILO GENERAL ----------- */
    body {
      margin: 0;
      font-family: 'Georgia', serif;
      line-height: 1.8;
      background-color: #f8f9fa;
      color: #333;
    }

    /* ----------- ENCABEZADO ----------- */
       .portada {
      height: 40vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1d2671, #c33764);
      color: white;
      text-align: center;
    }

    .overlay {
      background: rgba(0, 0, 0, 0.5);
      padding: 30px 60px;
      border-radius: 10px;
      max-width: 900px;
    }
    .overlay h3 {
      font-size: 1.6rem;
      margin: 10px 0;
      font-weight: 400;
    }

    .overlay p {
      font-style: italic;
      font-size: 1rem;
    }

    /* ----------- CONTENIDO PRINCIPAL ----------- */
    main {
      max-width: 1000px;
      margin: auto;
      padding: 40px 25px;
      background: #fff;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      margin-top: -30px;
      border-radius: 8px;
    }

    main h3 {
      margin-top: 30px;
      color: #1d2671;
      border-left: 5px solid #c33764;
      padding-left: 12px;
    }

    main p {
      text-align: justify;
      margin-bottom: 18px;
    }

    strong {
      color: #c33764;
    }

    /* ----------- PIE DE PÁGINA ----------- */
    footer {
      text-align: center;
      padding: 15px;
      margin-top: 40px;
      background: #1d2671;
      color: white;
      font-size: 0.9rem;
    }

        /* ---------------- MENU ---------------- */
    .menu-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: transparent;
      border: none;
      cursor: pointer;
      z-index: 1001;
    }

    .menu-btn div {
      width: 30px;
      height: 3px;
      background: white;
      margin: 6px 0;
      transition: 0.4s;
    }

    /* Navegación oculta */
    nav {
      position: fixed;
      top: 0;
      right: -250px;
      width: 250px;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: right 0.4s ease;
      z-index: 1000;
    }

    nav a {
      color: #fff;
      text-decoration: none;
      margin: 15px 0;
      font-size: 1.2rem;
      transition: color 0.3s;
    }

    nav a:hover {
      color: #ffd633;
    }

    nav.active {
      right: 0;
    }
  </style>
</head>
<body>
   <!-- Botón menú -->
    <button class="menu-btn" onclick="toggleMenu()">
      <div></div>
      <div></div>
      <div></div>
    </button>

    <!-- Menú lateral -->
    <nav id="menu">
      <a href="index.html">Inicio</a>
      <a href="Investigacion.html">Conceptos</a>
      <a href="ejemplos.html">Algoritmos</a>
      <a href="Referencias.html">Referencias</a>
    </nav>
  
  <!-- Encabezado con título y subtítulo -->
  <header class="portada">
    <div class="overlay">
      <h2>Recursividad</h2>
      <p>Proyecto académico de Estructura de Datos</p>
    </div>
  </header>

  <!-- Contenido -->
  <main class="contenido">
    <section>
      <h3>¿Qué es?</h3>
      <p>
        La <strong>recursividad</strong> es una técnica fundamental en programación que consiste en que una función 
        se llame a sí misma para resolver un problema, dividiéndolo en subproblemas cada vez más pequeños hasta alcanzar
        un caso base que detiene el proceso. Este enfoque permite expresar soluciones complejas de manera clara,
        estructurada y, en muchos casos, más corta que con métodos iterativos tradicionales. Gracias a la recursividad, 
        es posible abordar problemas como el cálculo de factoriales, la serie de Fibonacci, el recorrido de estructuras
        de datos (árboles, grafos) y la resolución de algoritmos clásicos como el de las Torres de Hanói o la búsqueda 
        binaria. Además, fomenta el pensamiento lógico al obligar al programador a descomponer un problema en pasos más
        simples, siguiendo el principio de "divide y vencerás". [1]
      </p>

      <p>
        <strong>Cómo funciona la recursividad:</strong>  
        El elemento clave en una función recursiva es que debe tener al menos una condición base (o caso base), que es un
        criterio claramente definido que termina la recursión. Sin esta condición base, la función podría llamarse a sí misma
        indefinidamente, causando un desbordamiento de pila (<em>stack overflow</em>).Simplifica la lógica en estructuras 
        jerárquicas, búsquedas y algoritmos como árboles, grafos o fractales.  
      </p> 
         
      <p>
        <strong>Desventajas:</strong>  
        Puede ser menos eficiente en memoria y tiempo por la sobrecarga de múltiples llamadas. Sin caso base claro, puede
        ocasionar errores.  
      </p>

      <p>
        <strong>Tipos de recursividad:</strong> 
        <ul>
        <li>Recursividad simple:</li>
           donde la función se llama a sí misma una sola vez por ejecución, como en el cálculo del factorial.
        <li>Recursividad múltiple:</li>
          donde la función se llama varias veces a sí misma durante la ejecución de una instancia, como en la sucesión de Fibonacci.
        <li>Recursividad mutua:</li>
          donde dos o más funciones se llaman cíclicamente entre sí.
         </ul>
      </p>

       <center><img src="one.png" style="max-width:200px; border-radius:10px; margin:15px 0;"></center>

      <h3>Procedimientos recursivos y sus aplicaciones</h3>
      <p>
        Los procesos recursivos tienen aplicaciones que van desde la resolución de algoritmos matemáticos hasta la
        manipulación estructural de datos complejos:

        <ul>
        <li><strong>Algoritmos matemáticos:</strong> cálculo de factoriales, números de Fibonacci, y soluciones a problemas clásicos como
        las Torres de Hanoi, optimización y búsqueda.</li>
        
        <li><strong>Estructuras de datos:</strong> recorrido y manipulación de árboles, listas enlazadas y grafos. Las llamadas recursivas
        permiten recorrer estas estructuras complejas de forma natural y eficiente.</li>
        
        <li><strong>División y conquista:</strong> técnicas como MergeSort y QuickSort dividen el problema original en subproblemas más pequeños
        que se resuelven recursivamente y luego se combinan para obtener la solución final.</li>
        
        <li><strong>Generación de fractales:</strong> la recursividad también se utiliza para crear complejos objetos geométricos auto-similares,
        como los fractales en forma de árbol, el triángulo de Sierpinski o la curva de Koch.</li>
        
        <li><strong>Inteligencia artificial y lógica:</strong> en lenguajes como Prolog la recursividad se usa para expresar reglas y relaciones
        complejas de manera eficiente y elegante.</li>
        
        <li><strong>Modelado de fenómenos naturales:</strong> muchas estructuras y procesos naturales muestran patrones recursivos o
        auto-similares, desde la ramificación de árboles hasta redes de ríos.</li>
        </ul>
      </p>
        
 <center><img src="dos.png" style="max-width:400px; border-radius:10px; margin:15px 0;"></center>
        
      <h3>Características de la recursividad</h3>
        <p>
          <ul>
          <li><strong>Auto-similitud:</strong> Las estructuras recursivas presentan partes que se parecen a la estructura completa, como pasa
          en los árboles donde cada subárbol es en sí un árbol.</li>
          
          <li><strong>Recorridos recursivos:</strong> Las funciones recursivas son ideales para recorrer estas estructuras, visitando nodos o
          elementos mediante llamadas que exploran cada subestructura. Por ejemplo, en un árbol binario se pueden hacer 
          recorridos en preorden, inorden y postorden con funciones recursivas.</li>
          
           <li><strong>Facilitan operaciones complejas:</strong> Inserciones, eliminaciones, búsquedas y modificaciones en estas estructuras se pueden
          implementar elegantemente con recursividad.</li>
          
           <li><strong>Contexto de ejecución:</strong> Cada llamada recursiva mantiene su propio contexto en la pila, permitiendo manejar múltiples
          niveles de profundidad sin perder información.</li>
          
           <li><strong>Optimización:</strong> Aunque la recursividad es natural para estas estructuras, a veces puede ser optimizada o reemplazada
          por técnicas iterativas o recursión de cola para reducir el uso de memoria.</li>
         </ul>
      </p>
    </section>

     <center><img src="tres.png" style="max-width:500px; border-radius:10px; margin:15px 0;"></center>
    
     <section>
        <h3>Complejidad computacional en algoritmos recursivos</h3>
        <p>
          La <strong>complejidad computacional</strong> en algoritmos recursivos se analiza considerando tanto el número de llamadas recursivas que
          realiza el algoritmo como el costo computacional (tiempo o espacio) de cada una de esas llamadas. A diferencia de los
          algoritmos iterativos, donde la complejidad suele calcularse sumando operaciones, en los recursivos se utilizan ecuaciones
          de recurrencia para describir el tiempo de ejecución y resolverlas.
      </p>
    </section>  
  </main>
  
  <!-- Pie de página -->
  <footer>
    © 2025 Proyecto de Recursividad | Equipo académico
  </footer>

</body>
</html>
